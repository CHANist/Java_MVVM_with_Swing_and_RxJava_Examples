= Java MVVM with Swing, RxJava and RxSwing examples
Peti Koch
:imagesdir: ./docs
:project-name: Java_MVVM_with_Swing_and_RxJava_Examples
:github-branch: master
:github-user: Petikoch
:bintray-user: petikoch

image:http://img.shields.io/badge/license-ASF2-blue.svg["Apache License 2", link="http://www.apache.org/licenses/LICENSE-2.0.txt"]
image:https://travis-ci.org/{github-user}/{project-name}.svg?branch={github-branch}["Build Status", link="https://travis-ci.org/{github-user}/{project-name}"]

== Introduction

There are a lot of different architectures for the GUI:
https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller[*Model View Controller*],
https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter[*Model View Presenter*],
https://en.wikipedia.org/wiki/Model_View_ViewModel[*Model View ViewModel*],
http://martinfowler.com/eaaDev/PresentationModel.html[*PresentationModel*], ...

All of them try more or less

* to decouple the "different things" (widgets, forms, business logic, ...) from each other
* make the "different things" easily testable (unit-testable)
* try to separate presentation from behaviour
* make the view easily "exchangeable"
* concentrate the business logic into e.g. the model, which "lives longer" (in years) than the often changing GUI technologies
* ...

When you develop a Java Swing GUI in practice, you face the following additional challenges

* how to enforce the proper threading (view elements like JPanel, JButton, ... should be only accessed by AWT-EventDispatchThread)
* how to keep the view "responsive" by kicking off background actions (-> SwingWorker, new Thread(...), ExecutorService, ...)
* how to connect an ActionListener on e.g. a "Cancel" button with a just started SwingWorker and disconnect it after the SwingWorker finished
* how to combine the results from multiple asynchronous actions (multiple SwingWorker's, Thread's, Future's, ...) into one result for the view
* how to enforce acyclic relationships between "stuff" to get good (isolated) testability
* ...

So, which GUI architecture should you choose? What are the benefits and drawbacks?
Which are the important benefits/drawbacks for your current project?
What libraries are available to make "quick progress" and not reinvent the wheel?

These are a lot of questions which are IMO not easily answered for a Java Swing GUI.

=== The idea

One day, I had a deep lock at https://en.wikipedia.org/wiki/Model_View_ViewModel[*MVVM*] and came up with the idea of

* using https://github.com/ReactiveX/RxJava[RxJava]'s http://reactivex.io/documentation/subject.html[Subject] objects as "listenable" value objects for the ViewModel
* https://github.com/ReactiveX/RxSwing[RxSwing] to connect the View widgets (JButton, JTextField, ...) to the ViewModel-Subjects as "data binding"
* https://github.com/ReactiveX/RxJava[RxJava] to react on changes of the ViewModel-Subjects and interact with the Model (backend)
* use RxJava's http://reactivex.io/documentation/scheduler.html[Scheduler] and the RxSwing https://github.com/ReactiveX/RxSwing/blob/0.x/src/main/java/rx/schedulers/SwingScheduler.java[SwingScheduler] to do the threading

The solution was really nice and I'd like to share it with you through this github repo.

=== Implementing MVVM using RxJava and RxSwing

First, let's look at the "data flow" in MVVM:

image::MVVMPattern.png[]

* The View interacts with the ViewModel through DataBinding (this means in practise you don't see any method calls, listeners etc in your sourcecode. You just see "binding" code.)
* The View doesn't interact with the Model
* The ViewModel interacts with the Model through ordinary Model API call's
* The Model API has some kind of callbacks to push data up to the ViewModel (dashed arrow)

Second, let's look at the dependencies:

image::MVVM_dependencies.png[]

* The View "sees" the ViewModel
* The View "doesn't see" the Model
* The ViewModel "sees" the model
* The Model "doesn't see" the ViewModel and "doesn't see" the View
* We have acyclic dependencies

==== Basic ideas behind the examples here

* Threading
** All the action between View -> ViewModel and ViewModel -> View happens on the SwingScheduler
** All the action between ViewModel -> Model happens on Schedulers.io() (= cached thread pool)

* View
** DataBinding
*** We add a little "Binder" fluent API a la https://github.com/canoo/open-dolphin/blob/master/subprojects/shared/src/main/groovy/org/opendolphin/binding/Binder.groovy[open-dolphin's Binder] on top of RxJava
** There is no other code than a) DataBinding code and b) plain GUI code in the View
** "Large" View's are composed by combining multiple "small" View's

* ViewModel
** Per View exits a ViewModel
** The ViewModel represents the structure of the View 1:1
** We use http://reactivex.io/documentation/subject.html[Subject]'s as "fields" in the ViewModel
*** Each subject "field" in the ViewModel corresponds to one widget in the View
*** We use a little prefix for the "field" name like 'v2vm_' or 'vm2v_' to indicate the flow direction
*** We use the BehaviorSubject class for Subject instances, which is a stateful Subject to have the "current" state, an initial state and easy testability
** The ViewModel handles all the "complicated" interaction stuff between View and Model

* Model
** The Model doesn't care about it's presentation and just offers an API
** The Model is therefore fully focused on business logic and data

=== Examples

TODO

== Requirements

* Java *8* or later

== Feedback

Please use GitHub issues and pull requests for feedback or contributions.

== Motivation

TODO



Best regards,

image::Signature.jpg[]